#!/usr/bin/env python
from duckie_utils.instantiate_utils import instantiate
from duckie_utils.image import DuckieImageToBGRMat
from line_detector.stats import Stats
import cv2
import numpy as np
import threading
import time
import yaml
import sys, argparse

import RobotRaconteur as RR
RRN = RR.RobotRaconteurNode.s

lineDetector_servicedef="""
#Service to provide interface to Duckiebots Detected Lines
service Duckiebot_Interface

option version 0.8

option constant uint8 WHITE 0
option constant uint8 YELLOW 1
option constant uint8 RED 2

struct Vector2D
    field double x 
    field double y
end struct

struct Point
    field double x
    field double y
    field double z
end struct

struct Segment
    field uint8 color
    field Vector2D{list} pixels_normalized
    field Vector2D normal
    field Point{list} points
end struct

object LineDetector
    property Segment{list} segments

    # likely want some way of clients only checking when new segments found.
    #pipe Segment{list} segmentStream
    event newSegments(Segment{list} segs)
end object
"""

class LineDetector_impl(object):
    """Line Detector Node will return detected lines."""
    def __init__(self, config_file=None):
        self.node_name = "lineDetector"

        self._segments = []
        self.LDConsts = RRN.GetConstants("Duckiebot_Interface")
        
        # Thread lock
        self.thread_lock = threading.Lock()

        self.active = True

        self.stats = Stats()

        # only print every 10 cycles
        self.intermittent_interval = 100
        self.intermittent_counter = 0

        # load param files
        with open('${DEFAULT_LANE_PARAMS}','r') as f:
            self.default_params = yaml.load(f.read())

        if config_file is not None:
            with open(config_file, 'r') as f:
                self.params = yaml.load(f.read())
        else:
            self.params = self.default_params

        # extract the params
        self.image_size = self.params['img_size']
        self.top_cutoff = self.params['top_cutoff']

        # extract the detector params
        c = self.params['detector']
        assert isinstance(c,list) and len(c) == 2, c

        print "[%s] new detector config: %s"%(self.node_name, str(c))

        # instantiate it
        #   c[0] is the detector type -- e.g. line_detector.LineDetectorHSV
        #   c[1] is the configuration dictionary
        self.detector = instantiate(c[0],c[1])
        
        # Find the image service and connect to the pipe
        try:
            cam_url = 'rr+local:///?nodename=DuckiebotServer.Camera&service=Duckiebot_Camera'
            self.duckie_cam = RRN.ConnectService(cam_url)
        except Exception as e:
            print "[%s] WARNING: Could not connect to Camera Interface at %s"%(self.node_name, cam_url)
            print "[%s] will wait 5 seconds and try again..."
            time.sleep(5)
            try:
                self.duckie_cam = RRN.ConnectService(cam_url)
            except Exception as e:
                msg = "[%s] ERROR: Still could not connect to Camera Interface at %s\n"%(self.node_name, cam_url)
                msg+= "[%s] Shutting down." %(self.node_name)
                raise RuntimeError(msg)
        
        self.imstream = self.duckie_cam.ImageStream.Connect(-1) # connect to the pipe
        self.imstream.PacketReceivedEvent+=self._cbImage

        try:
            self.duckie_cam.startCapturing()
        except: pass

        self.newSegments = RR.EventHook()
    
    @property
    def segments(self):
        return self._segments

    def intermittent_log_now(self):
        return self.intermittent_counter % self.intermittent_interval == 1

    def intermittent_log(self,s):
        if not self.intermittent_log_now():
            return
        msg = "[%s] %3d:%s"%(self.node_name, self.intermittent_counter, s)
        print msg

    def _cbImage(self, pipe_ep):
        while (pipe_ep.Available > 0):
            self.stats.received()
            image=pipe_ep.ReceivePacket()

        if not self.active:
            return

        #start a daemon thread to process the image
        thread = threading.Thread(target=self._processImage, args=(image,))
        thread.setDaemon(True)
        thread.start()
        # this returns right away...

    def _processImage(self,image):
        if not self.thread_lock.acquire(False): # False indicates non-blocking
            self.stats.skipped()
            # return immediately if the thread is locked
            return

        try:
            self.__processImage(image)
        finally:
            # release the thread lock
            self.thread_lock.release()

    def __processImage(self,image):
        self.stats.processed()

        if self.intermittent_log_now():
            self.intermittent_log(self.stats.info())
            self.stats.reset()

        self.intermittent_counter += 1

        # extract the image data
        try:
            image_cv = DuckieImageToBGRMat(image)
        except ValueError as e:
            print "[%s] Could not decode image: %s"%(self.node_name, e)
            return

        # resize and crop image
        h_original, w_original = image_cv.shape[0:2]

        if self.image_size[0] != h_original or self.image_size[1] != w_original:
            image_cv = cv2.resize(image_cv, (self.image_size[1], self.image_size[0]),
                interpolation=cv2.INTER_NEAREST)
            image_cv = image_cv[self.top_cutoff:,:,:]

        # apply color correction ... 
        # ADD IN LATER IF NEEDED

        # set the image to be detected
        self.detector.setImage(image_cv)

        # Detect lines and normals
        white = self.detector.detectLines('white')
        yellow = self.detector.detectLines('yellow')
        red = self.detector.detectLines('red')

        # Reset the segments list
        self._segments = []

        # convert to normalized pixel coordinates, and add segments to segment list
        arr_cutoff = np.array((0, self.top_cutoff, 0, self.top_cutoff))
        arr_ratio = np.array((1./self.image_size[1], 1./self.image_size[0], 1./self.image_size[1], 1./self.image_size[0] ))
        
        if len(white.lines) > 0:
            lines_normalized_white = ((white.lines + arr_cutoff) * arr_ratio)
            self._segments.extend(self.toSegment(lines_normalized_white, white.normals, self.LDConsts.WHITE))
        
        if len(yellow.lines) > 0:
            lines_normalized_yellow = ((yellow.lines + arr_cutoff) * arr_ratio)
            self._segments.extend(self.toSegment(lines_normalized_yellow, yellow.normals, self.LDConsts.YELLOW))
        
        if len(red.lines) > 0:
            lines_normalized_red = ((red.lines + arr_cutoff) * arr_ratio)
            self._segments.extend(self.toSegment(lines_normalized_red, red.normals, self.LDConsts.RED))

        self.newSegments.fire(self._segments)
        self.intermittent_log('# segments: white %3d yellow %3d red %3d' % (len(white.lines),
                len(yellow.lines), len(red.lines)))


    def toSegment(self, lines, normals, color):
        segmentList = []
        for x1,y1,x2,y2,norm_x,norm_y in np.hstack((lines,normals)):
            segment = RRN.NewStructure("DuckiebotInterface.Segment")
            segment.color = color
            segment.pixels_normalized[0].x = x1
            segment.pixels_normalized[0].y = y1
            segment.pixels_normalized[1].x = x2
            segment.pixels_normalized[2].y = y2
            segment.normal.x = norm_x
            segment.normal.y = norm_y

            segmentList.append(segment)
        return segmentList

    def onShutdown(self):
        self.imstream.Close()
        print "[%s] Shutdown."%(self.node_name)


if __name__ == '__main__':
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description='Initialize the line detector')
    parser.add_argument('--config', type=open,
        help='A config file for the line detector (Otherwise use Default)')
    parser.add_argument('args', nargs=argparse.REMAINDER)

    args = parser.parse_args(sys.argv[1:])

    # Enable NumPy
    RRN.UseNumPy = True

    # Create a local transport only
    t1 = RR.LocalTransport()
    t1.StartServerAsNodeName("DuckiebotServer.LineDetector")
    RRN.RegisterTransport(t1)

    # Register the service def
    RRN.RegisterServiceType(lineDetector_servicedef)

    # Initialize the object
    LD_obj = LineDetector_impl(args.config)

    # Register the service
    RRN.RegisterService("LineDetector","Duckiebot_Interface.LineDetector",LD_obj)

    print "Service started, connect via the following:"
    print "rr+local:///?nodename=DuckiebotServer.LineDetector&service=LineDetector"

    try:
        while True:
            pass
    except(KeyboardInterrupt, SystemExit):
        LD_obj.onShutdown()

        # This must be here to prevent segfault
        RRN.Shutdown()
        sys.exit(0)
